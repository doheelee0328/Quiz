{"ast":null,"code":"import _slicedToArray from \"/Users/doheelee/Quiz/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/doheelee/Quiz/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/doheelee/Quiz/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/doheelee/Quiz/client/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/doheelee/Quiz/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"/Users/doheelee/Quiz/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n// src/devModeChecks/identityFunctionCheck.ts\nvar runIdentityFunctionCheck = function runIdentityFunctionCheck(resultFunc) {\n  var isInputSameAsOutput = false;\n  try {\n    var emptyObject = {};\n    if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true;\n  } catch (_unused) {}\n  if (isInputSameAsOutput) {\n    var stack = void 0;\n    try {\n      throw new Error();\n    } catch (e) {\n      ;\n      stack = e.stack;\n    }\n    console.warn(\"The result function returned its own inputs without modification. e.g\\n`createSelector([state => state.todos], todos => todos)`\\nThis could lead to inefficient memoization and unnecessary re-renders.\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.\", {\n      stack: stack\n    });\n  }\n};\n\n// src/devModeChecks/inputStabilityCheck.ts\nvar runInputStabilityCheck = function runInputStabilityCheck(inputSelectorResultsObject, options, inputSelectorArgs) {\n  var memoize = options.memoize,\n    memoizeOptions = options.memoizeOptions;\n  var inputSelectorResults = inputSelectorResultsObject.inputSelectorResults,\n    inputSelectorResultsCopy = inputSelectorResultsObject.inputSelectorResultsCopy;\n  var createAnEmptyObject = memoize.apply(void 0, [function () {\n    return {};\n  }].concat(_toConsumableArray(memoizeOptions)));\n  var areInputSelectorResultsEqual = createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy);\n  if (!areInputSelectorResultsEqual) {\n    var stack = void 0;\n    try {\n      throw new Error();\n    } catch (e) {\n      ;\n      stack = e.stack;\n    }\n    console.warn(\"An input selector returned a different result when passed same arguments.\\nThis means your output selector will likely run more frequently than intended.\\nAvoid returning a new reference inside your input selector, e.g.\\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`\", {\n      arguments: inputSelectorArgs,\n      firstInputs: inputSelectorResults,\n      secondInputs: inputSelectorResultsCopy,\n      stack: stack\n    });\n  }\n};\n\n// src/devModeChecks/setGlobalDevModeChecks.ts\nvar globalDevModeChecks = {\n  inputStabilityCheck: \"once\",\n  identityFunctionCheck: \"once\"\n};\nvar setGlobalDevModeChecks = function setGlobalDevModeChecks(devModeChecks) {\n  Object.assign(globalDevModeChecks, devModeChecks);\n};\n\n// src/utils.ts\nvar NOT_FOUND = \"NOT_FOUND\";\nfunction assertIsFunction(func) {\n  var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"expected a function, instead received \".concat(typeof func);\n  if (typeof func !== \"function\") {\n    throw new TypeError(errorMessage);\n  }\n}\nfunction assertIsObject(object) {\n  var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"expected an object, instead received \".concat(typeof object);\n  if (typeof object !== \"object\") {\n    throw new TypeError(errorMessage);\n  }\n}\nfunction assertIsArrayOfFunctions(array) {\n  var errorMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"expected all items to be functions, instead received the following types: \";\n  if (!array.every(function (item) {\n    return typeof item === \"function\";\n  })) {\n    var itemTypes = array.map(function (item) {\n      return typeof item === \"function\" ? \"function \".concat(item.name || \"unnamed\", \"()\") : typeof item;\n    }).join(\", \");\n    throw new TypeError(\"\".concat(errorMessage, \"[\").concat(itemTypes, \"]\"));\n  }\n}\nvar ensureIsArray = function ensureIsArray(item) {\n  return Array.isArray(item) ? item : [item];\n};\nfunction getDependencies(createSelectorArgs) {\n  var dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;\n  assertIsArrayOfFunctions(dependencies, \"createSelector expects all input-selectors to be functions, but received the following types: \");\n  return dependencies;\n}\nfunction collectInputSelectorResults(dependencies, inputSelectorArgs) {\n  var inputSelectorResults = [];\n  var length = dependencies.length;\n  for (var i = 0; i < length; i++) {\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));\n  }\n  return inputSelectorResults;\n}\nvar getDevModeChecksExecutionInfo = function getDevModeChecksExecutionInfo(firstRun, devModeChecks) {\n  var _globalDevModeChecks$ = _objectSpread(_objectSpread({}, globalDevModeChecks), devModeChecks),\n    identityFunctionCheck = _globalDevModeChecks$.identityFunctionCheck,\n    inputStabilityCheck = _globalDevModeChecks$.inputStabilityCheck;\n  return {\n    identityFunctionCheck: {\n      shouldRun: identityFunctionCheck === \"always\" || identityFunctionCheck === \"once\" && firstRun,\n      run: runIdentityFunctionCheck\n    },\n    inputStabilityCheck: {\n      shouldRun: inputStabilityCheck === \"always\" || inputStabilityCheck === \"once\" && firstRun,\n      run: runInputStabilityCheck\n    }\n  };\n};\n\n// src/autotrackMemoize/autotracking.ts\nvar $REVISION = 0;\nvar CURRENT_TRACKER = null;\nvar Cell = /*#__PURE__*/function () {\n  function Cell(initialValue) {\n    var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tripleEq;\n    _classCallCheck(this, Cell);\n    _defineProperty(this, \"revision\", $REVISION);\n    _defineProperty(this, \"_value\", void 0);\n    _defineProperty(this, \"_lastValue\", void 0);\n    _defineProperty(this, \"_isEqual\", tripleEq);\n    this._value = this._lastValue = initialValue;\n    this._isEqual = isEqual;\n  }\n  // Whenever a storage value is read, it'll add itself to the current tracker if\n  // one exists, entangling its state with that cache.\n  _createClass(Cell, [{\n    key: \"value\",\n    get: function get() {\n      var _CURRENT_TRACKER;\n      (_CURRENT_TRACKER = CURRENT_TRACKER) === null || _CURRENT_TRACKER === void 0 || _CURRENT_TRACKER.add(this);\n      return this._value;\n    }\n    // Whenever a storage value is updated, we bump the global revision clock,\n    // assign the revision for this storage to the new value, _and_ we schedule a\n    // rerender. This is important, and it's what makes autotracking  _pull_\n    // based. We don't actively tell the caches which depend on the storage that\n    // anything has happened. Instead, we recompute the caches when needed.\n    ,\n    set: function set(newValue) {\n      if (this.value === newValue) return;\n      this._value = newValue;\n      this.revision = ++$REVISION;\n    }\n  }]);\n  return Cell;\n}();\nfunction tripleEq(a, b) {\n  return a === b;\n}\nvar TrackingCache = /*#__PURE__*/function () {\n  function TrackingCache(fn) {\n    _classCallCheck(this, TrackingCache);\n    _defineProperty(this, \"_cachedValue\", void 0);\n    _defineProperty(this, \"_cachedRevision\", -1);\n    _defineProperty(this, \"_deps\", []);\n    _defineProperty(this, \"hits\", 0);\n    _defineProperty(this, \"fn\", void 0);\n    this.fn = fn;\n  }\n  _createClass(TrackingCache, [{\n    key: \"clear\",\n    value: function clear() {\n      this._cachedValue = void 0;\n      this._cachedRevision = -1;\n      this._deps = [];\n      this.hits = 0;\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      var _CURRENT_TRACKER2;\n      if (this.revision > this._cachedRevision) {\n        var fn = this.fn;\n        var currentTracker = /* @__PURE__ */new Set();\n        var prevTracker = CURRENT_TRACKER;\n        CURRENT_TRACKER = currentTracker;\n        this._cachedValue = fn();\n        CURRENT_TRACKER = prevTracker;\n        this.hits++;\n        this._deps = Array.from(currentTracker);\n        this._cachedRevision = this.revision;\n      }\n      (_CURRENT_TRACKER2 = CURRENT_TRACKER) === null || _CURRENT_TRACKER2 === void 0 || _CURRENT_TRACKER2.add(this);\n      return this._cachedValue;\n    }\n  }, {\n    key: \"revision\",\n    get: function get() {\n      return Math.max.apply(Math, _toConsumableArray(this._deps.map(function (d) {\n        return d.revision;\n      })).concat([0]));\n    }\n  }]);\n  return TrackingCache;\n}();\nfunction getValue(cell) {\n  if (!(cell instanceof Cell)) {\n    console.warn(\"Not a valid cell! \", cell);\n  }\n  return cell.value;\n}\nfunction setValue(storage, value) {\n  if (!(storage instanceof Cell)) {\n    throw new TypeError(\"setValue must be passed a tracked store created with `createStorage`.\");\n  }\n  storage.value = storage._lastValue = value;\n}\nfunction createCell(initialValue) {\n  var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tripleEq;\n  return new Cell(initialValue, isEqual);\n}\nfunction createCache(fn) {\n  assertIsFunction(fn, \"the first parameter to `createCache` must be a function\");\n  return new TrackingCache(fn);\n}\n\n// src/autotrackMemoize/tracking.ts\nvar neverEq = function neverEq(a, b) {\n  return false;\n};\nfunction createTag() {\n  return createCell(null, neverEq);\n}\nfunction dirtyTag(tag, value) {\n  setValue(tag, value);\n}\nvar consumeCollection = function consumeCollection(node) {\n  var tag = node.collectionTag;\n  if (tag === null) {\n    tag = node.collectionTag = createTag();\n  }\n  getValue(tag);\n};\nvar dirtyCollection = function dirtyCollection(node) {\n  var tag = node.collectionTag;\n  if (tag !== null) {\n    dirtyTag(tag, null);\n  }\n};\n\n// src/autotrackMemoize/proxy.ts\nvar REDUX_PROXY_LABEL = Symbol();\nvar nextId = 0;\nvar proto = Object.getPrototypeOf({});\nvar ObjectTreeNode = /*#__PURE__*/_createClass(function ObjectTreeNode(value) {\n  _classCallCheck(this, ObjectTreeNode);\n  _defineProperty(this, \"proxy\", new Proxy(this, objectProxyHandler));\n  _defineProperty(this, \"tag\", createTag());\n  _defineProperty(this, \"tags\", {});\n  _defineProperty(this, \"children\", {});\n  _defineProperty(this, \"collectionTag\", null);\n  _defineProperty(this, \"id\", nextId++);\n  this.value = value;\n  this.value = value;\n  this.tag.value = value;\n});\nvar objectProxyHandler = {\n  get: function get(node, key) {\n    function calculateResult() {\n      var value = node.value;\n      var childValue = Reflect.get(value, key);\n      if (typeof key === \"symbol\") {\n        return childValue;\n      }\n      if (key in proto) {\n        return childValue;\n      }\n      if (typeof childValue === \"object\" && childValue !== null) {\n        var childNode = node.children[key];\n        if (childNode === void 0) {\n          childNode = node.children[key] = createNode(childValue);\n        }\n        if (childNode.tag) {\n          getValue(childNode.tag);\n        }\n        return childNode.proxy;\n      } else {\n        var tag = node.tags[key];\n        if (tag === void 0) {\n          tag = node.tags[key] = createTag();\n          tag.value = childValue;\n        }\n        getValue(tag);\n        return childValue;\n      }\n    }\n    var res = calculateResult();\n    return res;\n  },\n  ownKeys: function ownKeys(node) {\n    consumeCollection(node);\n    return Reflect.ownKeys(node.value);\n  },\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(node, prop) {\n    return Reflect.getOwnPropertyDescriptor(node.value, prop);\n  },\n  has: function has(node, prop) {\n    return Reflect.has(node.value, prop);\n  }\n};\nvar ArrayTreeNode = /*#__PURE__*/_createClass(function ArrayTreeNode(value) {\n  _classCallCheck(this, ArrayTreeNode);\n  _defineProperty(this, \"proxy\", new Proxy([this], arrayProxyHandler));\n  _defineProperty(this, \"tag\", createTag());\n  _defineProperty(this, \"tags\", {});\n  _defineProperty(this, \"children\", {});\n  _defineProperty(this, \"collectionTag\", null);\n  _defineProperty(this, \"id\", nextId++);\n  this.value = value;\n  this.value = value;\n  this.tag.value = value;\n});\nvar arrayProxyHandler = {\n  get: function get(_ref, key) {\n    var _ref2 = _slicedToArray(_ref, 1),\n      node = _ref2[0];\n    if (key === \"length\") {\n      consumeCollection(node);\n    }\n    return objectProxyHandler.get(node, key);\n  },\n  ownKeys: function ownKeys(_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 1),\n      node = _ref4[0];\n    return objectProxyHandler.ownKeys(node);\n  },\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(_ref5, prop) {\n    var _ref6 = _slicedToArray(_ref5, 1),\n      node = _ref6[0];\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop);\n  },\n  has: function has(_ref7, prop) {\n    var _ref8 = _slicedToArray(_ref7, 1),\n      node = _ref8[0];\n    return objectProxyHandler.has(node, prop);\n  }\n};\nfunction createNode(value) {\n  if (Array.isArray(value)) {\n    return new ArrayTreeNode(value);\n  }\n  return new ObjectTreeNode(value);\n}\nfunction updateNode(node, newValue) {\n  var value = node.value,\n    tags = node.tags,\n    children = node.children;\n  node.value = newValue;\n  if (Array.isArray(value) && Array.isArray(newValue) && value.length !== newValue.length) {\n    dirtyCollection(node);\n  } else {\n    if (value !== newValue) {\n      var oldKeysSize = 0;\n      var newKeysSize = 0;\n      var anyKeysAdded = false;\n      for (var _key in value) {\n        oldKeysSize++;\n      }\n      for (var key in newValue) {\n        newKeysSize++;\n        if (!(key in value)) {\n          anyKeysAdded = true;\n          break;\n        }\n      }\n      var isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize;\n      if (isDifferent) {\n        dirtyCollection(node);\n      }\n    }\n  }\n  for (var _key2 in tags) {\n    var childValue = value[_key2];\n    var newChildValue = newValue[_key2];\n    if (childValue !== newChildValue) {\n      dirtyCollection(node);\n      dirtyTag(tags[_key2], newChildValue);\n    }\n    if (typeof newChildValue === \"object\" && newChildValue !== null) {\n      delete tags[_key2];\n    }\n  }\n  for (var _key3 in children) {\n    var childNode = children[_key3];\n    var _newChildValue = newValue[_key3];\n    var _childValue = childNode.value;\n    if (_childValue === _newChildValue) {\n      continue;\n    } else if (typeof _newChildValue === \"object\" && _newChildValue !== null) {\n      updateNode(childNode, _newChildValue);\n    } else {\n      deleteNode(childNode);\n      delete children[_key3];\n    }\n  }\n}\nfunction deleteNode(node) {\n  if (node.tag) {\n    dirtyTag(node.tag, null);\n  }\n  dirtyCollection(node);\n  for (var key in node.tags) {\n    dirtyTag(node.tags[key], null);\n  }\n  for (var _key4 in node.children) {\n    deleteNode(node.children[_key4]);\n  }\n}\n\n// src/lruMemoize.ts\nfunction createSingletonCache(equals) {\n  var entry;\n  return {\n    get: function get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n      return NOT_FOUND;\n    },\n    put: function put(key, value) {\n      entry = {\n        key: key,\n        value: value\n      };\n    },\n    getEntries: function getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear: function clear() {\n      entry = void 0;\n    }\n  };\n}\nfunction createLruCache(maxSize, equals) {\n  var entries = [];\n  function get(key) {\n    var cacheIndex = entries.findIndex(function (entry) {\n      return equals(key, entry.key);\n    });\n    if (cacheIndex > -1) {\n      var entry = entries[cacheIndex];\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n      return entry.value;\n    }\n    return NOT_FOUND;\n  }\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      entries.unshift({\n        key: key,\n        value: value\n      });\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n  function getEntries() {\n    return entries;\n  }\n  function clear() {\n    entries = [];\n  }\n  return {\n    get: get,\n    put: put,\n    getEntries: getEntries,\n    clear: clear\n  };\n}\nvar referenceEqualityCheck = function referenceEqualityCheck(a, b) {\n  return a === b;\n};\nfunction createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    }\n    var length = prev.length;\n    for (var i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n    return true;\n  };\n}\nfunction lruMemoize(func, equalityCheckOrOptions) {\n  var providedOptions = typeof equalityCheckOrOptions === \"object\" ? equalityCheckOrOptions : {\n    equalityCheck: equalityCheckOrOptions\n  };\n  var _providedOptions$equa = providedOptions.equalityCheck,\n    equalityCheck = _providedOptions$equa === void 0 ? referenceEqualityCheck : _providedOptions$equa,\n    _providedOptions$maxS = providedOptions.maxSize,\n    maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,\n    resultEqualityCheck = providedOptions.resultEqualityCheck;\n  var comparator = createCacheKeyComparator(equalityCheck);\n  var resultsCount = 0;\n  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);\n  function memoized() {\n    var value = cache.get(arguments);\n    if (value === NOT_FOUND) {\n      value = func.apply(null, arguments);\n      resultsCount++;\n      if (resultEqualityCheck) {\n        var entries = cache.getEntries();\n        var matchingEntry = entries.find(function (entry) {\n          return resultEqualityCheck(entry.value, value);\n        });\n        if (matchingEntry) {\n          value = matchingEntry.value;\n          resultsCount !== 0 && resultsCount--;\n        }\n      }\n      cache.put(arguments, value);\n    }\n    return value;\n  }\n  memoized.clearCache = function () {\n    cache.clear();\n    memoized.resetResultsCount();\n  };\n  memoized.resultsCount = function () {\n    return resultsCount;\n  };\n  memoized.resetResultsCount = function () {\n    resultsCount = 0;\n  };\n  return memoized;\n}\n\n// src/autotrackMemoize/autotrackMemoize.ts\nfunction autotrackMemoize(func) {\n  var node = createNode([]);\n  var lastArgs = null;\n  var shallowEqual = createCacheKeyComparator(referenceEqualityCheck);\n  var cache = createCache(function () {\n    var res = func.apply(null, node.proxy);\n    return res;\n  });\n  function memoized() {\n    if (!shallowEqual(lastArgs, arguments)) {\n      updateNode(node, arguments);\n      lastArgs = arguments;\n    }\n    return cache.value;\n  }\n  memoized.clearCache = function () {\n    return cache.clear();\n  };\n  return memoized;\n}\n\n// src/weakMapMemoize.ts\nvar StrongRef = /*#__PURE__*/function () {\n  function StrongRef(value) {\n    _classCallCheck(this, StrongRef);\n    this.value = value;\n  }\n  _createClass(StrongRef, [{\n    key: \"deref\",\n    value: function deref() {\n      return this.value;\n    }\n  }]);\n  return StrongRef;\n}();\nvar Ref = typeof WeakRef !== \"undefined\" ? WeakRef : StrongRef;\nvar UNTERMINATED = 0;\nvar TERMINATED = 1;\nfunction createCacheNode() {\n  return {\n    s: UNTERMINATED,\n    v: void 0,\n    o: null,\n    p: null\n  };\n}\nfunction weakMapMemoize(func) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var fnNode = createCacheNode();\n  var resultEqualityCheck = options.resultEqualityCheck;\n  var lastResult;\n  var resultsCount = 0;\n  function memoized() {\n    var cacheNode = fnNode;\n    var length = arguments.length;\n    for (var i = 0, l = length; i < l; i++) {\n      var arg = arguments[i];\n      if (typeof arg === \"function\" || typeof arg === \"object\" && arg !== null) {\n        var objectCache = cacheNode.o;\n        if (objectCache === null) {\n          cacheNode.o = objectCache = /* @__PURE__ */new WeakMap();\n        }\n        var objectNode = objectCache.get(arg);\n        if (objectNode === void 0) {\n          cacheNode = createCacheNode();\n          objectCache.set(arg, cacheNode);\n        } else {\n          cacheNode = objectNode;\n        }\n      } else {\n        var primitiveCache = cacheNode.p;\n        if (primitiveCache === null) {\n          cacheNode.p = primitiveCache = /* @__PURE__ */new Map();\n        }\n        var primitiveNode = primitiveCache.get(arg);\n        if (primitiveNode === void 0) {\n          cacheNode = createCacheNode();\n          primitiveCache.set(arg, cacheNode);\n        } else {\n          cacheNode = primitiveNode;\n        }\n      }\n    }\n    var terminatedNode = cacheNode;\n    var result;\n    if (cacheNode.s === TERMINATED) {\n      result = cacheNode.v;\n    } else {\n      result = func.apply(null, arguments);\n      resultsCount++;\n    }\n    terminatedNode.s = TERMINATED;\n    if (resultEqualityCheck) {\n      var _lastResult$deref, _lastResult;\n      var lastResultValue = (_lastResult$deref = (_lastResult = lastResult) === null || _lastResult === void 0 ? void 0 : _lastResult.deref()) !== null && _lastResult$deref !== void 0 ? _lastResult$deref : lastResult;\n      if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {\n        result = lastResultValue;\n        resultsCount !== 0 && resultsCount--;\n      }\n      var needsWeakRef = typeof result === \"object\" && result !== null || typeof result === \"function\";\n      lastResult = needsWeakRef ? new Ref(result) : result;\n    }\n    terminatedNode.v = result;\n    return result;\n  }\n  memoized.clearCache = function () {\n    fnNode = createCacheNode();\n    memoized.resetResultsCount();\n  };\n  memoized.resultsCount = function () {\n    return resultsCount;\n  };\n  memoized.resetResultsCount = function () {\n    resultsCount = 0;\n  };\n  return memoized;\n}\n\n// src/createSelectorCreator.ts\nfunction createSelectorCreator(memoizeOrOptions) {\n  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key5 = 1; _key5 < _len; _key5++) {\n    memoizeOptionsFromArgs[_key5 - 1] = arguments[_key5];\n  }\n  var createSelectorCreatorOptions = typeof memoizeOrOptions === \"function\" ? {\n    memoize: memoizeOrOptions,\n    memoizeOptions: memoizeOptionsFromArgs\n  } : memoizeOrOptions;\n  var createSelector2 = function createSelector2() {\n    for (var _len2 = arguments.length, createSelectorArgs = new Array(_len2), _key6 = 0; _key6 < _len2; _key6++) {\n      createSelectorArgs[_key6] = arguments[_key6];\n    }\n    var _recomputations = 0;\n    var _dependencyRecomputations = 0;\n    var _lastResult2;\n    var directlyPassedOptions = {};\n    var resultFunc = createSelectorArgs.pop();\n    if (typeof resultFunc === \"object\") {\n      directlyPassedOptions = resultFunc;\n      resultFunc = createSelectorArgs.pop();\n    }\n    assertIsFunction(resultFunc, \"createSelector expects an output function after the inputs, but received: [\".concat(typeof resultFunc, \"]\"));\n    var combinedOptions = _objectSpread(_objectSpread({}, createSelectorCreatorOptions), directlyPassedOptions);\n    var memoize = combinedOptions.memoize,\n      _combinedOptions$memo = combinedOptions.memoizeOptions,\n      memoizeOptions = _combinedOptions$memo === void 0 ? [] : _combinedOptions$memo,\n      _combinedOptions$args = combinedOptions.argsMemoize,\n      argsMemoize = _combinedOptions$args === void 0 ? weakMapMemoize : _combinedOptions$args,\n      _combinedOptions$args2 = combinedOptions.argsMemoizeOptions,\n      argsMemoizeOptions = _combinedOptions$args2 === void 0 ? [] : _combinedOptions$args2,\n      _combinedOptions$devM = combinedOptions.devModeChecks,\n      devModeChecks = _combinedOptions$devM === void 0 ? {} : _combinedOptions$devM;\n    var finalMemoizeOptions = ensureIsArray(memoizeOptions);\n    var finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);\n    var dependencies = getDependencies(createSelectorArgs);\n    var memoizedResultFunc = memoize.apply(void 0, [function recomputationWrapper() {\n      _recomputations++;\n      return resultFunc.apply(null, arguments);\n    }].concat(_toConsumableArray(finalMemoizeOptions)));\n    var firstRun = true;\n    var selector = argsMemoize.apply(void 0, [function dependenciesChecker() {\n      _dependencyRecomputations++;\n      var inputSelectorResults = collectInputSelectorResults(dependencies, arguments);\n      if (process.env.NODE_ENV !== \"production\") {\n        var _getDevModeChecksExec = getDevModeChecksExecutionInfo(firstRun, devModeChecks),\n          identityFunctionCheck = _getDevModeChecksExec.identityFunctionCheck,\n          inputStabilityCheck = _getDevModeChecksExec.inputStabilityCheck;\n        if (identityFunctionCheck.shouldRun) {\n          identityFunctionCheck.run(resultFunc);\n        }\n        if (inputStabilityCheck.shouldRun) {\n          var inputSelectorResultsCopy = collectInputSelectorResults(dependencies, arguments);\n          inputStabilityCheck.run({\n            inputSelectorResults: inputSelectorResults,\n            inputSelectorResultsCopy: inputSelectorResultsCopy\n          }, {\n            memoize: memoize,\n            memoizeOptions: finalMemoizeOptions\n          }, arguments);\n        }\n        if (firstRun) firstRun = false;\n      }\n      _lastResult2 = memoizedResultFunc.apply(null, inputSelectorResults);\n      return _lastResult2;\n    }].concat(_toConsumableArray(finalArgsMemoizeOptions)));\n    return Object.assign(selector, {\n      resultFunc: resultFunc,\n      memoizedResultFunc: memoizedResultFunc,\n      dependencies: dependencies,\n      dependencyRecomputations: function dependencyRecomputations() {\n        return _dependencyRecomputations;\n      },\n      resetDependencyRecomputations: function resetDependencyRecomputations() {\n        _dependencyRecomputations = 0;\n      },\n      lastResult: function lastResult() {\n        return _lastResult2;\n      },\n      recomputations: function recomputations() {\n        return _recomputations;\n      },\n      resetRecomputations: function resetRecomputations() {\n        _recomputations = 0;\n      },\n      memoize: memoize,\n      argsMemoize: argsMemoize\n    });\n  };\n  return createSelector2;\n}\nvar createSelector = /* @__PURE__ */createSelectorCreator(weakMapMemoize);\n\n// src/createStructuredSelector.ts\nvar createStructuredSelector = function createStructuredSelector(inputSelectorsObject) {\n  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;\n  assertIsObject(inputSelectorsObject, \"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a \".concat(typeof inputSelectorsObject));\n  var inputSelectorKeys = Object.keys(inputSelectorsObject);\n  var dependencies = inputSelectorKeys.map(function (key) {\n    return inputSelectorsObject[key];\n  });\n  var structuredSelector = selectorCreator(dependencies, function () {\n    for (var _len3 = arguments.length, inputSelectorResults = new Array(_len3), _key7 = 0; _key7 < _len3; _key7++) {\n      inputSelectorResults[_key7] = arguments[_key7];\n    }\n    return inputSelectorResults.reduce(function (composition, value, index) {\n      composition[inputSelectorKeys[index]] = value;\n      return composition;\n    }, {});\n  });\n  return structuredSelector;\n};\nexport { createSelector, createSelectorCreator, createStructuredSelector, lruMemoize, referenceEqualityCheck, setGlobalDevModeChecks, autotrackMemoize as unstable_autotrackMemoize, weakMapMemoize };","map":{"version":3,"names":["runIdentityFunctionCheck","resultFunc","isInputSameAsOutput","emptyObject","_unused","stack","Error","e","console","warn","runInputStabilityCheck","inputSelectorResultsObject","options","inputSelectorArgs","memoize","memoizeOptions","inputSelectorResults","inputSelectorResultsCopy","createAnEmptyObject","apply","concat","_toConsumableArray","areInputSelectorResultsEqual","arguments","firstInputs","secondInputs","globalDevModeChecks","inputStabilityCheck","identityFunctionCheck","setGlobalDevModeChecks","devModeChecks","Object","assign","NOT_FOUND","assertIsFunction","func","errorMessage","length","undefined","TypeError","assertIsObject","object","assertIsArrayOfFunctions","array","every","item","itemTypes","map","name","join","ensureIsArray","Array","isArray","getDependencies","createSelectorArgs","dependencies","collectInputSelectorResults","i","push","getDevModeChecksExecutionInfo","firstRun","_globalDevModeChecks$","_objectSpread","shouldRun","run","$REVISION","CURRENT_TRACKER","Cell","initialValue","isEqual","tripleEq","_classCallCheck","_defineProperty","_value","_lastValue","_isEqual","_createClass","key","get","_CURRENT_TRACKER","add","set","newValue","value","revision","a","b","TrackingCache","fn","clear","_cachedValue","_cachedRevision","_deps","hits","_CURRENT_TRACKER2","currentTracker","Set","prevTracker","from","Math","max","d","getValue","cell","setValue","storage","createCell","createCache","neverEq","createTag","dirtyTag","tag","consumeCollection","node","collectionTag","dirtyCollection","REDUX_PROXY_LABEL","Symbol","nextId","proto","getPrototypeOf","ObjectTreeNode","Proxy","objectProxyHandler","calculateResult","childValue","Reflect","childNode","children","createNode","proxy","tags","res","ownKeys","getOwnPropertyDescriptor","prop","has","ArrayTreeNode","arrayProxyHandler","_ref","_ref2","_slicedToArray","_ref3","_ref4","_ref5","_ref6","_ref7","_ref8","updateNode","oldKeysSize","newKeysSize","anyKeysAdded","_key","isDifferent","newChildValue","deleteNode","createSingletonCache","equals","entry","put","getEntries","createLruCache","maxSize","entries","cacheIndex","findIndex","splice","unshift","pop","referenceEqualityCheck","createCacheKeyComparator","equalityCheck","areArgumentsShallowlyEqual","prev","next","lruMemoize","equalityCheckOrOptions","providedOptions","_providedOptions$equa","_providedOptions$maxS","resultEqualityCheck","comparator","resultsCount","cache","memoized","matchingEntry","find","clearCache","resetResultsCount","autotrackMemoize","lastArgs","shallowEqual","StrongRef","deref","Ref","WeakRef","UNTERMINATED","TERMINATED","createCacheNode","s","v","o","p","weakMapMemoize","fnNode","lastResult","cacheNode","l","arg","objectCache","WeakMap","objectNode","primitiveCache","Map","primitiveNode","terminatedNode","result","_lastResult$deref","_lastResult","lastResultValue","needsWeakRef","createSelectorCreator","memoizeOrOptions","_len","memoizeOptionsFromArgs","_key5","createSelectorCreatorOptions","createSelector2","_len2","_key6","recomputations","dependencyRecomputations","directlyPassedOptions","combinedOptions","_combinedOptions$memo","_combinedOptions$args","argsMemoize","_combinedOptions$args2","argsMemoizeOptions","_combinedOptions$devM","finalMemoizeOptions","finalArgsMemoizeOptions","memoizedResultFunc","recomputationWrapper","selector","dependenciesChecker","process","env","NODE_ENV","_getDevModeChecksExec","resetDependencyRecomputations","resetRecomputations","createSelector","createStructuredSelector","inputSelectorsObject","selectorCreator","inputSelectorKeys","keys","structuredSelector","_len3","_key7","reduce","composition","index"],"sources":["/Users/doheelee/Quiz/client/node_modules/reselect/src/devModeChecks/identityFunctionCheck.ts","/Users/doheelee/Quiz/client/node_modules/reselect/src/devModeChecks/inputStabilityCheck.ts","/Users/doheelee/Quiz/client/node_modules/reselect/src/devModeChecks/setGlobalDevModeChecks.ts","/Users/doheelee/Quiz/client/node_modules/reselect/src/utils.ts","/Users/doheelee/Quiz/client/node_modules/reselect/src/autotrackMemoize/autotracking.ts","/Users/doheelee/Quiz/client/node_modules/reselect/src/autotrackMemoize/tracking.ts","/Users/doheelee/Quiz/client/node_modules/reselect/src/autotrackMemoize/proxy.ts","/Users/doheelee/Quiz/client/node_modules/reselect/src/lruMemoize.ts","/Users/doheelee/Quiz/client/node_modules/reselect/src/autotrackMemoize/autotrackMemoize.ts","/Users/doheelee/Quiz/client/node_modules/reselect/src/weakMapMemoize.ts","/Users/doheelee/Quiz/client/node_modules/reselect/src/createSelectorCreator.ts","/Users/doheelee/Quiz/client/node_modules/reselect/src/createStructuredSelector.ts"],"sourcesContent":["import type { AnyFunction } from '../types'\r\n\r\n/**\r\n * Runs a check to determine if the given result function behaves as an\r\n * identity function. An identity function is one that returns its\r\n * input unchanged, for example, `x => x`. This check helps ensure\r\n * efficient memoization and prevent unnecessary re-renders by encouraging\r\n * proper use of transformation logic in result functions and\r\n * extraction logic in input selectors.\r\n *\r\n * @param resultFunc - The result function to be checked.\r\n *\r\n * @see {@link https://reselect.js.org/api/development-only-stability-checks#identityfunctioncheck `identityFunctionCheck`}\r\n *\r\n * @since 5.0.0\r\n * @internal\r\n */\r\nexport const runIdentityFunctionCheck = (resultFunc: AnyFunction) => {\r\n  let isInputSameAsOutput = false\r\n  try {\r\n    const emptyObject = {}\r\n    if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true\r\n  } catch {\r\n    // Do nothing\r\n  }\r\n  if (isInputSameAsOutput) {\r\n    let stack: string | undefined = undefined\r\n    try {\r\n      throw new Error()\r\n    } catch (e) {\r\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi, no-extra-semi\r\n      ;({ stack } = e as Error)\r\n    }\r\n    console.warn(\r\n      'The result function returned its own inputs without modification. e.g' +\r\n        '\\n`createSelector([state => state.todos], todos => todos)`' +\r\n        '\\nThis could lead to inefficient memoization and unnecessary re-renders.' +\r\n        '\\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.',\r\n      { stack }\r\n    )\r\n  }\r\n}\r\n","import type { CreateSelectorOptions, UnknownMemoizer } from '../types'\r\n\r\n/**\r\n * Runs a stability check to ensure the input selector results remain stable\r\n * when provided with the same arguments. This function is designed to detect\r\n * changes in the output of input selectors, which can impact the performance of memoized selectors.\r\n *\r\n * @param inputSelectorResultsObject - An object containing two arrays: `inputSelectorResults` and `inputSelectorResultsCopy`, representing the results of input selectors.\r\n * @param options - Options object consisting of a `memoize` function and a `memoizeOptions` object.\r\n * @param inputSelectorArgs - List of arguments being passed to the input selectors.\r\n *\r\n * @see {@link https://reselect.js.org/api/development-only-stability-checks/#inputstabilitycheck `inputStabilityCheck`}\r\n *\r\n * @since 5.0.0\r\n * @internal\r\n */\r\nexport const runInputStabilityCheck = (\r\n  inputSelectorResultsObject: {\r\n    inputSelectorResults: unknown[]\r\n    inputSelectorResultsCopy: unknown[]\r\n  },\r\n  options: Required<\r\n    Pick<\r\n      CreateSelectorOptions<UnknownMemoizer, UnknownMemoizer>,\r\n      'memoize' | 'memoizeOptions'\r\n    >\r\n  >,\r\n  inputSelectorArgs: unknown[] | IArguments\r\n) => {\r\n  const { memoize, memoizeOptions } = options\r\n  const { inputSelectorResults, inputSelectorResultsCopy } =\r\n    inputSelectorResultsObject\r\n  const createAnEmptyObject = memoize(() => ({}), ...memoizeOptions)\r\n  // if the memoize method thinks the parameters are equal, these *should* be the same reference\r\n  const areInputSelectorResultsEqual =\r\n    createAnEmptyObject.apply(null, inputSelectorResults) ===\r\n    createAnEmptyObject.apply(null, inputSelectorResultsCopy)\r\n  if (!areInputSelectorResultsEqual) {\r\n    let stack: string | undefined = undefined\r\n    try {\r\n      throw new Error()\r\n    } catch (e) {\r\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi, no-extra-semi\r\n      ;({ stack } = e as Error)\r\n    }\r\n    console.warn(\r\n      'An input selector returned a different result when passed same arguments.' +\r\n        '\\nThis means your output selector will likely run more frequently than intended.' +\r\n        '\\nAvoid returning a new reference inside your input selector, e.g.' +\r\n        '\\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`',\r\n      {\r\n        arguments: inputSelectorArgs,\r\n        firstInputs: inputSelectorResults,\r\n        secondInputs: inputSelectorResultsCopy,\r\n        stack\r\n      }\r\n    )\r\n  }\r\n}\r\n","import type { DevModeChecks } from '../types'\r\n\r\n/**\r\n * Global configuration for development mode checks. This specifies the default\r\n * frequency at which each development mode check should be performed.\r\n *\r\n * @since 5.0.0\r\n * @internal\r\n */\r\nexport const globalDevModeChecks: DevModeChecks = {\r\n  inputStabilityCheck: 'once',\r\n  identityFunctionCheck: 'once'\r\n}\r\n\r\n/**\r\n * Overrides the development mode checks settings for all selectors.\r\n *\r\n * Reselect performs additional checks in development mode to help identify and\r\n * warn about potential issues in selector behavior. This function allows you to\r\n * customize the behavior of these checks across all selectors in your application.\r\n *\r\n * **Note**: This setting can still be overridden per selector inside `createSelector`'s `options` object.\r\n * See {@link https://github.com/reduxjs/reselect#2-per-selector-by-passing-an-identityfunctioncheck-option-directly-to-createselector per-selector-configuration}\r\n * and {@linkcode CreateSelectorOptions.identityFunctionCheck identityFunctionCheck} for more details.\r\n *\r\n * _The development mode checks do not run in production builds._\r\n *\r\n * @param devModeChecks - An object specifying the desired settings for development mode checks. You can provide partial overrides. Unspecified settings will retain their current values.\r\n *\r\n * @example\r\n * ```ts\r\n * import { setGlobalDevModeChecks } from 'reselect'\r\n * import { DevModeChecks } from '../types'\r\n *\r\n * // Run only the first time the selector is called. (default)\r\n * setGlobalDevModeChecks({ inputStabilityCheck: 'once' })\r\n *\r\n * // Run every time the selector is called.\r\n * setGlobalDevModeChecks({ inputStabilityCheck: 'always' })\r\n *\r\n * // Never run the input stability check.\r\n * setGlobalDevModeChecks({ inputStabilityCheck: 'never' })\r\n *\r\n * // Run only the first time the selector is called. (default)\r\n * setGlobalDevModeChecks({ identityFunctionCheck: 'once' })\r\n *\r\n * // Run every time the selector is called.\r\n * setGlobalDevModeChecks({ identityFunctionCheck: 'always' })\r\n *\r\n * // Never run the identity function check.\r\n * setGlobalDevModeChecks({ identityFunctionCheck: 'never' })\r\n * ```\r\n * @see {@link https://reselect.js.org/api/development-only-stability-checks Development-Only Stability Checks}\r\n * @see {@link https://reselect.js.org/api/development-only-stability-checks#1-globally-through-setglobaldevmodechecks global-configuration}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport const setGlobalDevModeChecks = (\r\n  devModeChecks: Partial<DevModeChecks>\r\n) => {\r\n  Object.assign(globalDevModeChecks, devModeChecks)\r\n}\r\n","import { runIdentityFunctionCheck } from './devModeChecks/identityFunctionCheck'\r\nimport { runInputStabilityCheck } from './devModeChecks/inputStabilityCheck'\r\nimport { globalDevModeChecks } from './devModeChecks/setGlobalDevModeChecks'\r\n// eslint-disable-next-line @typescript-eslint/consistent-type-imports\r\nimport type {\r\n  DevModeChecks,\r\n  Selector,\r\n  SelectorArray,\r\n  DevModeChecksExecutionInfo\r\n} from './types'\r\n\r\nexport const NOT_FOUND = 'NOT_FOUND'\r\nexport type NOT_FOUND_TYPE = typeof NOT_FOUND\r\n\r\n/**\r\n * Assert that the provided value is a function. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param func - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsFunction<FunctionType extends Function>(\r\n  func: unknown,\r\n  errorMessage = `expected a function, instead received ${typeof func}`\r\n): asserts func is FunctionType {\r\n  if (typeof func !== 'function') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided value is an object. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param object - The value to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsObject<ObjectType extends Record<string, unknown>>(\r\n  object: unknown,\r\n  errorMessage = `expected an object, instead received ${typeof object}`\r\n): asserts object is ObjectType {\r\n  if (typeof object !== 'object') {\r\n    throw new TypeError(errorMessage)\r\n  }\r\n}\r\n\r\n/**\r\n * Assert that the provided array is an array of functions. If the assertion fails,\r\n * a `TypeError` is thrown with an optional custom error message.\r\n *\r\n * @param array - The array to be checked.\r\n * @param  errorMessage - An optional custom error message to use if the assertion fails.\r\n * @throws A `TypeError` if the assertion fails.\r\n */\r\nexport function assertIsArrayOfFunctions<FunctionType extends Function>(\r\n  array: unknown[],\r\n  errorMessage = `expected all items to be functions, instead received the following types: `\r\n): asserts array is FunctionType[] {\r\n  if (\r\n    !array.every((item): item is FunctionType => typeof item === 'function')\r\n  ) {\r\n    const itemTypes = array\r\n      .map(item =>\r\n        typeof item === 'function'\r\n          ? `function ${item.name || 'unnamed'}()`\r\n          : typeof item\r\n      )\r\n      .join(', ')\r\n    throw new TypeError(`${errorMessage}[${itemTypes}]`)\r\n  }\r\n}\r\n\r\n/**\r\n * Ensure that the input is an array. If it's already an array, it's returned as is.\r\n * If it's not an array, it will be wrapped in a new array.\r\n *\r\n * @param item - The item to be checked.\r\n * @returns An array containing the input item. If the input is already an array, it's returned without modification.\r\n */\r\nexport const ensureIsArray = (item: unknown) => {\r\n  return Array.isArray(item) ? item : [item]\r\n}\r\n\r\n/**\r\n * Extracts the \"dependencies\" / \"input selectors\" from the arguments of `createSelector`.\r\n *\r\n * @param createSelectorArgs - Arguments passed to `createSelector` as an array.\r\n * @returns An array of \"input selectors\" / \"dependencies\".\r\n * @throws A `TypeError` if any of the input selectors is not function.\r\n */\r\nexport function getDependencies(createSelectorArgs: unknown[]) {\r\n  const dependencies = Array.isArray(createSelectorArgs[0])\r\n    ? createSelectorArgs[0]\r\n    : createSelectorArgs\r\n\r\n  assertIsArrayOfFunctions<Selector>(\r\n    dependencies,\r\n    `createSelector expects all input-selectors to be functions, but received the following types: `\r\n  )\r\n\r\n  return dependencies as SelectorArray\r\n}\r\n\r\n/**\r\n * Runs each input selector and returns their collective results as an array.\r\n *\r\n * @param dependencies - An array of \"dependencies\" or \"input selectors\".\r\n * @param inputSelectorArgs - An array of arguments being passed to the input selectors.\r\n * @returns An array of input selector results.\r\n */\r\nexport function collectInputSelectorResults(\r\n  dependencies: SelectorArray,\r\n  inputSelectorArgs: unknown[] | IArguments\r\n) {\r\n  const inputSelectorResults = []\r\n  const { length } = dependencies\r\n  for (let i = 0; i < length; i++) {\r\n    // @ts-ignore\r\n    // apply arguments instead of spreading and mutate a local list of params for performance.\r\n    inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs))\r\n  }\r\n  return inputSelectorResults\r\n}\r\n\r\n/**\r\n * Retrieves execution information for development mode checks.\r\n *\r\n * @param devModeChecks - Custom Settings for development mode checks. These settings will override the global defaults.\r\n * @param firstRun - Indicates whether it is the first time the selector has run.\r\n * @returns  An object containing the execution information for each development mode check.\r\n */\r\nexport const getDevModeChecksExecutionInfo = (\r\n  firstRun: boolean,\r\n  devModeChecks: Partial<DevModeChecks>\r\n) => {\r\n  const { identityFunctionCheck, inputStabilityCheck } = {\r\n    ...globalDevModeChecks,\r\n    ...devModeChecks\r\n  }\r\n  return {\r\n    identityFunctionCheck: {\r\n      shouldRun:\r\n        identityFunctionCheck === 'always' ||\r\n        (identityFunctionCheck === 'once' && firstRun),\r\n      run: runIdentityFunctionCheck\r\n    },\r\n    inputStabilityCheck: {\r\n      shouldRun:\r\n        inputStabilityCheck === 'always' ||\r\n        (inputStabilityCheck === 'once' && firstRun),\r\n      run: runInputStabilityCheck\r\n    }\r\n  } satisfies DevModeChecksExecutionInfo\r\n}\r\n","// Original autotracking implementation source:\r\n// - https://gist.github.com/pzuraq/79bf862e0f8cd9521b79c4b6eccdc4f9\r\n// Additional references:\r\n// - https://www.pzuraq.com/blog/how-autotracking-works\r\n// - https://v5.chriskrycho.com/journal/autotracking-elegant-dx-via-cutting-edge-cs/\r\nimport type { EqualityFn } from '../types'\r\nimport { assertIsFunction } from '../utils'\r\n\r\n// The global revision clock. Every time state changes, the clock increments.\r\nexport let $REVISION = 0\r\n\r\n// The current dependency tracker. Whenever we compute a cache, we create a Set\r\n// to track any dependencies that are used while computing. If no cache is\r\n// computing, then the tracker is null.\r\nlet CURRENT_TRACKER: Set<Cell<any> | TrackingCache> | null = null\r\n\r\n// Storage represents a root value in the system - the actual state of our app.\r\nexport class Cell<T> {\r\n  revision = $REVISION\r\n\r\n  _value: T\r\n  _lastValue: T\r\n  _isEqual: EqualityFn = tripleEq\r\n\r\n  constructor(initialValue: T, isEqual: EqualityFn = tripleEq) {\r\n    this._value = this._lastValue = initialValue\r\n    this._isEqual = isEqual\r\n  }\r\n\r\n  // Whenever a storage value is read, it'll add itself to the current tracker if\r\n  // one exists, entangling its state with that cache.\r\n  get value() {\r\n    CURRENT_TRACKER?.add(this)\r\n\r\n    return this._value\r\n  }\r\n\r\n  // Whenever a storage value is updated, we bump the global revision clock,\r\n  // assign the revision for this storage to the new value, _and_ we schedule a\r\n  // rerender. This is important, and it's what makes autotracking  _pull_\r\n  // based. We don't actively tell the caches which depend on the storage that\r\n  // anything has happened. Instead, we recompute the caches when needed.\r\n  set value(newValue) {\r\n    if (this.value === newValue) return\r\n\r\n    this._value = newValue\r\n    this.revision = ++$REVISION\r\n  }\r\n}\r\n\r\nfunction tripleEq(a: unknown, b: unknown) {\r\n  return a === b\r\n}\r\n\r\n// Caches represent derived state in the system. They are ultimately functions\r\n// that are memoized based on what state they use to produce their output,\r\n// meaning they will only rerun IFF a storage value that could affect the output\r\n// has changed. Otherwise, they'll return the cached value.\r\nexport class TrackingCache {\r\n  _cachedValue: any\r\n  _cachedRevision = -1\r\n  _deps: any[] = []\r\n  hits = 0\r\n\r\n  fn: () => any\r\n\r\n  constructor(fn: () => any) {\r\n    this.fn = fn\r\n  }\r\n\r\n  clear() {\r\n    this._cachedValue = undefined\r\n    this._cachedRevision = -1\r\n    this._deps = []\r\n    this.hits = 0\r\n  }\r\n\r\n  get value() {\r\n    // When getting the value for a Cache, first we check all the dependencies of\r\n    // the cache to see what their current revision is. If the current revision is\r\n    // greater than the cached revision, then something has changed.\r\n    if (this.revision > this._cachedRevision) {\r\n      const { fn } = this\r\n\r\n      // We create a new dependency tracker for this cache. As the cache runs\r\n      // its function, any Storage or Cache instances which are used while\r\n      // computing will be added to this tracker. In the end, it will be the\r\n      // full list of dependencies that this Cache depends on.\r\n      const currentTracker = new Set<Cell<any>>()\r\n      const prevTracker = CURRENT_TRACKER\r\n\r\n      CURRENT_TRACKER = currentTracker\r\n\r\n      // try {\r\n      this._cachedValue = fn()\r\n      // } finally {\r\n      CURRENT_TRACKER = prevTracker\r\n      this.hits++\r\n      this._deps = Array.from(currentTracker)\r\n\r\n      // Set the cached revision. This is the current clock count of all the\r\n      // dependencies. If any dependency changes, this number will be less\r\n      // than the new revision.\r\n      this._cachedRevision = this.revision\r\n      // }\r\n    }\r\n\r\n    // If there is a current tracker, it means another Cache is computing and\r\n    // using this one, so we add this one to the tracker.\r\n    CURRENT_TRACKER?.add(this)\r\n\r\n    // Always return the cached value.\r\n    return this._cachedValue\r\n  }\r\n\r\n  get revision() {\r\n    // The current revision is the max of all the dependencies' revisions.\r\n    return Math.max(...this._deps.map(d => d.revision), 0)\r\n  }\r\n}\r\n\r\nexport function getValue<T>(cell: Cell<T>): T {\r\n  if (!(cell instanceof Cell)) {\r\n    console.warn('Not a valid cell! ', cell)\r\n  }\r\n\r\n  return cell.value\r\n}\r\n\r\ntype CellValue<T extends Cell<unknown>> = T extends Cell<infer U> ? U : never\r\n\r\nexport function setValue<T extends Cell<unknown>>(\r\n  storage: T,\r\n  value: CellValue<T>\r\n): void {\r\n  if (!(storage instanceof Cell)) {\r\n    throw new TypeError(\r\n      'setValue must be passed a tracked store created with `createStorage`.'\r\n    )\r\n  }\r\n\r\n  storage.value = storage._lastValue = value\r\n}\r\n\r\nexport function createCell<T = unknown>(\r\n  initialValue: T,\r\n  isEqual: EqualityFn = tripleEq\r\n): Cell<T> {\r\n  return new Cell(initialValue, isEqual)\r\n}\r\n\r\nexport function createCache<T = unknown>(fn: () => T): TrackingCache {\r\n  assertIsFunction(\r\n    fn,\r\n    'the first parameter to `createCache` must be a function'\r\n  )\r\n\r\n  return new TrackingCache(fn)\r\n}\r\n","import type { Cell } from './autotracking'\r\nimport {\r\n  getValue as consumeTag,\r\n  createCell as createStorage,\r\n  setValue\r\n} from './autotracking'\r\n\r\nexport type Tag = Cell<unknown>\r\n\r\nconst neverEq = (a: any, b: any): boolean => false\r\n\r\nexport function createTag(): Tag {\r\n  return createStorage(null, neverEq)\r\n}\r\nexport { consumeTag }\r\nexport function dirtyTag(tag: Tag, value: any): void {\r\n  setValue(tag, value)\r\n}\r\n\r\nexport interface Node<\r\n  T extends Array<unknown> | Record<string, unknown> =\r\n    | Array<unknown>\r\n    | Record<string, unknown>\r\n> {\r\n  collectionTag: Tag | null\r\n  tag: Tag | null\r\n  tags: Record<string, Tag>\r\n  children: Record<string, Node>\r\n  proxy: T\r\n  value: T\r\n  id: number\r\n}\r\n\r\nexport const consumeCollection = (node: Node): void => {\r\n  let tag = node.collectionTag\r\n\r\n  if (tag === null) {\r\n    tag = node.collectionTag = createTag()\r\n  }\r\n\r\n  consumeTag(tag)\r\n}\r\n\r\nexport const dirtyCollection = (node: Node): void => {\r\n  const tag = node.collectionTag\r\n\r\n  if (tag !== null) {\r\n    dirtyTag(tag, null)\r\n  }\r\n}\r\n","// Original source:\r\n// - https://github.com/simonihmig/tracked-redux/blob/master/packages/tracked-redux/src/-private/proxy.ts\r\n\r\nimport type { Node, Tag } from './tracking'\r\nimport {\r\n  consumeCollection,\r\n  consumeTag,\r\n  createTag,\r\n  dirtyCollection,\r\n  dirtyTag\r\n} from './tracking'\r\n\r\nexport const REDUX_PROXY_LABEL = Symbol()\r\n\r\nlet nextId = 0\r\n\r\nconst proto = Object.getPrototypeOf({})\r\n\r\nclass ObjectTreeNode<T extends Record<string, unknown>> implements Node<T> {\r\n  proxy: T = new Proxy(this, objectProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {} as Record<string, Tag>\r\n  children = {} as Record<string, Node>\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst objectProxyHandler = {\r\n  get(node: Node, key: string | symbol): unknown {\r\n    function calculateResult() {\r\n      const { value } = node\r\n\r\n      const childValue = Reflect.get(value, key)\r\n\r\n      if (typeof key === 'symbol') {\r\n        return childValue\r\n      }\r\n\r\n      if (key in proto) {\r\n        return childValue\r\n      }\r\n\r\n      if (typeof childValue === 'object' && childValue !== null) {\r\n        let childNode = node.children[key]\r\n\r\n        if (childNode === undefined) {\r\n          childNode = node.children[key] = createNode(childValue)\r\n        }\r\n\r\n        if (childNode.tag) {\r\n          consumeTag(childNode.tag)\r\n        }\r\n\r\n        return childNode.proxy\r\n      } else {\r\n        let tag = node.tags[key]\r\n\r\n        if (tag === undefined) {\r\n          tag = node.tags[key] = createTag()\r\n          tag.value = childValue\r\n        }\r\n\r\n        consumeTag(tag)\r\n\r\n        return childValue\r\n      }\r\n    }\r\n    const res = calculateResult()\r\n    return res\r\n  },\r\n\r\n  ownKeys(node: Node): ArrayLike<string | symbol> {\r\n    consumeCollection(node)\r\n    return Reflect.ownKeys(node.value)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    node: Node,\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return Reflect.getOwnPropertyDescriptor(node.value, prop)\r\n  },\r\n\r\n  has(node: Node, prop: string | symbol): boolean {\r\n    return Reflect.has(node.value, prop)\r\n  }\r\n}\r\n\r\nclass ArrayTreeNode<T extends Array<unknown>> implements Node<T> {\r\n  proxy: T = new Proxy([this], arrayProxyHandler) as unknown as T\r\n  tag = createTag()\r\n  tags = {}\r\n  children = {}\r\n  collectionTag = null\r\n  id = nextId++\r\n\r\n  constructor(public value: T) {\r\n    this.value = value\r\n    this.tag.value = value\r\n  }\r\n}\r\n\r\nconst arrayProxyHandler = {\r\n  get([node]: [Node], key: string | symbol): unknown {\r\n    if (key === 'length') {\r\n      consumeCollection(node)\r\n    }\r\n\r\n    return objectProxyHandler.get(node, key)\r\n  },\r\n\r\n  ownKeys([node]: [Node]): ArrayLike<string | symbol> {\r\n    return objectProxyHandler.ownKeys(node)\r\n  },\r\n\r\n  getOwnPropertyDescriptor(\r\n    [node]: [Node],\r\n    prop: string | symbol\r\n  ): PropertyDescriptor | undefined {\r\n    return objectProxyHandler.getOwnPropertyDescriptor(node, prop)\r\n  },\r\n\r\n  has([node]: [Node], prop: string | symbol): boolean {\r\n    return objectProxyHandler.has(node, prop)\r\n  }\r\n}\r\n\r\nexport function createNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  value: T\r\n): Node<T> {\r\n  if (Array.isArray(value)) {\r\n    return new ArrayTreeNode(value)\r\n  }\r\n\r\n  return new ObjectTreeNode(value) as Node<T>\r\n}\r\n\r\nconst keysMap = new WeakMap<\r\n  Array<unknown> | Record<string, unknown>,\r\n  Set<string>\r\n>()\r\n\r\nexport function updateNode<T extends Array<unknown> | Record<string, unknown>>(\r\n  node: Node<T>,\r\n  newValue: T\r\n): void {\r\n  const { value, tags, children } = node\r\n\r\n  node.value = newValue\r\n\r\n  if (\r\n    Array.isArray(value) &&\r\n    Array.isArray(newValue) &&\r\n    value.length !== newValue.length\r\n  ) {\r\n    dirtyCollection(node)\r\n  } else {\r\n    if (value !== newValue) {\r\n      let oldKeysSize = 0\r\n      let newKeysSize = 0\r\n      let anyKeysAdded = false\r\n\r\n      for (const _key in value) {\r\n        oldKeysSize++\r\n      }\r\n\r\n      for (const key in newValue) {\r\n        newKeysSize++\r\n        if (!(key in value)) {\r\n          anyKeysAdded = true\r\n          break\r\n        }\r\n      }\r\n\r\n      const isDifferent = anyKeysAdded || oldKeysSize !== newKeysSize\r\n\r\n      if (isDifferent) {\r\n        dirtyCollection(node)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (const key in tags) {\r\n    const childValue = (value as Record<string, unknown>)[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    if (childValue !== newChildValue) {\r\n      dirtyCollection(node)\r\n      dirtyTag(tags[key], newChildValue)\r\n    }\r\n\r\n    if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      delete tags[key]\r\n    }\r\n  }\r\n\r\n  for (const key in children) {\r\n    const childNode = children[key]\r\n    const newChildValue = (newValue as Record<string, unknown>)[key]\r\n\r\n    const childValue = childNode.value\r\n\r\n    if (childValue === newChildValue) {\r\n      continue\r\n    } else if (typeof newChildValue === 'object' && newChildValue !== null) {\r\n      updateNode(childNode, newChildValue as Record<string, unknown>)\r\n    } else {\r\n      deleteNode(childNode)\r\n      delete children[key]\r\n    }\r\n  }\r\n}\r\n\r\nfunction deleteNode(node: Node): void {\r\n  if (node.tag) {\r\n    dirtyTag(node.tag, null)\r\n  }\r\n  dirtyCollection(node)\r\n  for (const key in node.tags) {\r\n    dirtyTag(node.tags[key], null)\r\n  }\r\n  for (const key in node.children) {\r\n    deleteNode(node.children[key])\r\n  }\r\n}\r\n","import type {\r\n  AnyFunction,\r\n  DefaultMemoizeFields,\r\n  EqualityFn,\r\n  Simplify\r\n} from './types'\r\n\r\nimport type { NOT_FOUND_TYPE } from './utils'\r\nimport { NOT_FOUND } from './utils'\r\n\r\n// Cache implementation based on Erik Rasmussen's `lru-memoize`:\r\n// https://github.com/erikras/lru-memoize\r\n\r\ninterface Entry {\r\n  key: unknown\r\n  value: unknown\r\n}\r\n\r\ninterface Cache {\r\n  get(key: unknown): unknown | NOT_FOUND_TYPE\r\n  put(key: unknown, value: unknown): void\r\n  getEntries(): Entry[]\r\n  clear(): void\r\n}\r\n\r\nfunction createSingletonCache(equals: EqualityFn): Cache {\r\n  let entry: Entry | undefined\r\n  return {\r\n    get(key: unknown) {\r\n      if (entry && equals(entry.key, key)) {\r\n        return entry.value\r\n      }\r\n\r\n      return NOT_FOUND\r\n    },\r\n\r\n    put(key: unknown, value: unknown) {\r\n      entry = { key, value }\r\n    },\r\n\r\n    getEntries() {\r\n      return entry ? [entry] : []\r\n    },\r\n\r\n    clear() {\r\n      entry = undefined\r\n    }\r\n  }\r\n}\r\n\r\nfunction createLruCache(maxSize: number, equals: EqualityFn): Cache {\r\n  let entries: Entry[] = []\r\n\r\n  function get(key: unknown) {\r\n    const cacheIndex = entries.findIndex(entry => equals(key, entry.key))\r\n\r\n    // We found a cached entry\r\n    if (cacheIndex > -1) {\r\n      const entry = entries[cacheIndex]\r\n\r\n      // Cached entry not at top of cache, move it to the top\r\n      if (cacheIndex > 0) {\r\n        entries.splice(cacheIndex, 1)\r\n        entries.unshift(entry)\r\n      }\r\n\r\n      return entry.value\r\n    }\r\n\r\n    // No entry found in cache, return sentinel\r\n    return NOT_FOUND\r\n  }\r\n\r\n  function put(key: unknown, value: unknown) {\r\n    if (get(key) === NOT_FOUND) {\r\n      // TODO Is unshift slow?\r\n      entries.unshift({ key, value })\r\n      if (entries.length > maxSize) {\r\n        entries.pop()\r\n      }\r\n    }\r\n  }\r\n\r\n  function getEntries() {\r\n    return entries\r\n  }\r\n\r\n  function clear() {\r\n    entries = []\r\n  }\r\n\r\n  return { get, put, getEntries, clear }\r\n}\r\n\r\n/**\r\n * Runs a simple reference equality check.\r\n * What {@linkcode lruMemoize lruMemoize} uses by default.\r\n *\r\n * **Note**: This function was previously known as `defaultEqualityCheck`.\r\n *\r\n * @public\r\n */\r\nexport const referenceEqualityCheck: EqualityFn = (a, b) => a === b\r\n\r\nexport function createCacheKeyComparator(equalityCheck: EqualityFn) {\r\n  return function areArgumentsShallowlyEqual(\r\n    prev: unknown[] | IArguments | null,\r\n    next: unknown[] | IArguments | null\r\n  ): boolean {\r\n    if (prev === null || next === null || prev.length !== next.length) {\r\n      return false\r\n    }\r\n\r\n    // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\r\n    const { length } = prev\r\n    for (let i = 0; i < length; i++) {\r\n      if (!equalityCheck(prev[i], next[i])) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\n/**\r\n * Options for configuring the behavior of a function memoized with\r\n * LRU (Least Recently Used) caching.\r\n *\r\n * @template Result - The type of the return value of the memoized function.\r\n *\r\n * @public\r\n */\r\nexport interface LruMemoizeOptions<Result = any> {\r\n  /**\r\n   * Function used to compare the individual arguments of the\r\n   * provided calculation function.\r\n   *\r\n   * @default referenceEqualityCheck\r\n   */\r\n  equalityCheck?: EqualityFn\r\n\r\n  /**\r\n   * If provided, used to compare a newly generated output value against\r\n   * previous values in the cache. If a match is found,\r\n   * the old value is returned. This addresses the common\r\n   * ```ts\r\n   * todos.map(todo => todo.id)\r\n   * ```\r\n   * use case, where an update to another field in the original data causes\r\n   * a recalculation due to changed references, but the output is still\r\n   * effectively the same.\r\n   *\r\n   * @since 4.1.0\r\n   */\r\n  resultEqualityCheck?: EqualityFn<Result>\r\n\r\n  /**\r\n   * The maximum size of the cache used by the selector.\r\n   * A size greater than 1 means the selector will use an\r\n   * LRU (Least Recently Used) cache, allowing for the caching of multiple\r\n   * results based on different sets of arguments.\r\n   *\r\n   * @default 1\r\n   */\r\n  maxSize?: number\r\n}\r\n\r\n/**\r\n * Creates a memoized version of a function with an optional\r\n * LRU (Least Recently Used) cache. The memoized function uses a cache to\r\n * store computed values. Depending on the `maxSize` option, it will use\r\n * either a singleton cache (for a single entry) or an\r\n * LRU cache (for multiple entries).\r\n *\r\n * **Note**: This function was previously known as `defaultMemoize`.\r\n *\r\n * @param func - The function to be memoized.\r\n * @param equalityCheckOrOptions - Either an equality check function or an options object.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/lruMemoize `lruMemoize`}\r\n *\r\n * @public\r\n */\r\nexport function lruMemoize<Func extends AnyFunction>(\r\n  func: Func,\r\n  equalityCheckOrOptions?: EqualityFn | LruMemoizeOptions<ReturnType<Func>>\r\n) {\r\n  const providedOptions =\r\n    typeof equalityCheckOrOptions === 'object'\r\n      ? equalityCheckOrOptions\r\n      : { equalityCheck: equalityCheckOrOptions }\r\n\r\n  const {\r\n    equalityCheck = referenceEqualityCheck,\r\n    maxSize = 1,\r\n    resultEqualityCheck\r\n  } = providedOptions\r\n\r\n  const comparator = createCacheKeyComparator(equalityCheck)\r\n\r\n  let resultsCount = 0\r\n\r\n  const cache =\r\n    maxSize === 1\r\n      ? createSingletonCache(comparator)\r\n      : createLruCache(maxSize, comparator)\r\n\r\n  function memoized() {\r\n    let value = cache.get(arguments) as ReturnType<Func>\r\n    if (value === NOT_FOUND) {\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      value = func.apply(null, arguments) as ReturnType<Func>\r\n      resultsCount++\r\n\r\n      if (resultEqualityCheck) {\r\n        const entries = cache.getEntries()\r\n        const matchingEntry = entries.find(entry =>\r\n          resultEqualityCheck(entry.value as ReturnType<Func>, value)\r\n        )\r\n\r\n        if (matchingEntry) {\r\n          value = matchingEntry.value as ReturnType<Func>\r\n          resultsCount !== 0 && resultsCount--\r\n        }\r\n      }\r\n\r\n      cache.put(arguments, value)\r\n    }\r\n    return value\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    cache.clear()\r\n    memoized.resetResultsCount()\r\n  }\r\n\r\n  memoized.resultsCount = () => resultsCount\r\n\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","import { createNode, updateNode } from './proxy'\r\nimport type { Node } from './tracking'\r\n\r\nimport { createCacheKeyComparator, referenceEqualityCheck } from '../lruMemoize'\r\nimport type { AnyFunction, DefaultMemoizeFields, Simplify } from '../types'\r\nimport { createCache } from './autotracking'\r\n\r\n/**\r\n * Uses an \"auto-tracking\" approach inspired by the work of the Ember Glimmer team.\r\n * It uses a Proxy to wrap arguments and track accesses to nested fields\r\n * in your selector on first read. Later, when the selector is called with\r\n * new arguments, it identifies which accessed fields have changed and\r\n * only recalculates the result if one or more of those accessed fields have changed.\r\n * This allows it to be more precise than the shallow equality checks in `lruMemoize`.\r\n *\r\n * __Design Tradeoffs for `autotrackMemoize`:__\r\n * - Pros:\r\n *    - It is likely to avoid excess calculations and recalculate fewer times than `lruMemoize` will,\r\n *    which may also result in fewer component re-renders.\r\n * - Cons:\r\n *    - It only has a cache size of 1.\r\n *    - It is slower than `lruMemoize`, because it has to do more work. (How much slower is dependent on the number of accessed fields in a selector, number of calls, frequency of input changes, etc)\r\n *    - It can have some unexpected behavior. Because it tracks nested field accesses,\r\n *    cases where you don't access a field will not recalculate properly.\r\n *    For example, a badly-written selector like:\r\n *      ```ts\r\n *      createSelector([state => state.todos], todos => todos)\r\n *      ```\r\n *      that just immediately returns the extracted value will never update, because it doesn't see any field accesses to check.\r\n *\r\n * __Use Cases for `autotrackMemoize`:__\r\n * - It is likely best used for cases where you need to access specific nested fields\r\n * in data, and avoid recalculating if other fields in the same data objects are immutably updated.\r\n *\r\n * @param func - The function to be memoized.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @example\r\n * <caption>Using `createSelector`</caption>\r\n * ```ts\r\n * import { unstable_autotrackMemoize as autotrackMemoize, createSelector } from 'reselect'\r\n *\r\n * const selectTodoIds = createSelector(\r\n *   [(state: RootState) => state.todos],\r\n *   (todos) => todos.map(todo => todo.id),\r\n *   { memoize: autotrackMemoize }\r\n * )\r\n * ```\r\n *\r\n * @example\r\n * <caption>Using `createSelectorCreator`</caption>\r\n * ```ts\r\n * import { unstable_autotrackMemoize as autotrackMemoize, createSelectorCreator } from 'reselect'\r\n *\r\n * const createSelectorAutotrack = createSelectorCreator({ memoize: autotrackMemoize })\r\n *\r\n * const selectTodoIds = createSelectorAutotrack(\r\n *   [(state: RootState) => state.todos],\r\n *   (todos) => todos.map(todo => todo.id)\r\n * )\r\n * ```\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/unstable_autotrackMemoize autotrackMemoize}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @experimental\r\n */\r\nexport function autotrackMemoize<Func extends AnyFunction>(func: Func) {\r\n  // we reference arguments instead of spreading them for performance reasons\r\n\r\n  const node: Node<Record<string, unknown>> = createNode(\r\n    [] as unknown as Record<string, unknown>\r\n  )\r\n\r\n  let lastArgs: IArguments | null = null\r\n\r\n  const shallowEqual = createCacheKeyComparator(referenceEqualityCheck)\r\n\r\n  const cache = createCache(() => {\r\n    const res = func.apply(null, node.proxy as unknown as any[])\r\n    return res\r\n  })\r\n\r\n  function memoized() {\r\n    if (!shallowEqual(lastArgs, arguments)) {\r\n      updateNode(node, arguments as unknown as Record<string, unknown>)\r\n      lastArgs = arguments\r\n    }\r\n    return cache.value\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    return cache.clear()\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","// Original source:\r\n// - https://github.com/facebook/react/blob/0b974418c9a56f6c560298560265dcf4b65784bc/packages/react/src/ReactCache.js\r\n\r\nimport type {\r\n  AnyFunction,\r\n  DefaultMemoizeFields,\r\n  EqualityFn,\r\n  Simplify\r\n} from './types'\r\n\r\nclass StrongRef<T> {\r\n  constructor(private value: T) {}\r\n  deref() {\r\n    return this.value\r\n  }\r\n}\r\n\r\nconst Ref =\r\n  typeof WeakRef !== 'undefined'\r\n    ? WeakRef\r\n    : (StrongRef as unknown as typeof WeakRef)\r\n\r\nconst UNTERMINATED = 0\r\nconst TERMINATED = 1\r\n\r\ninterface UnterminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 0\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: void\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular Map where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ninterface TerminatedCacheNode<T> {\r\n  /**\r\n   * Status, represents whether the cached computation returned a value or threw an error.\r\n   */\r\n  s: 1\r\n  /**\r\n   * Value, either the cached result or an error, depending on status.\r\n   */\r\n  v: T\r\n  /**\r\n   * Object cache, a `WeakMap` where non-primitive arguments are stored.\r\n   */\r\n  o: null | WeakMap<Function | Object, CacheNode<T>>\r\n  /**\r\n   * Primitive cache, a regular `Map` where primitive arguments are stored.\r\n   */\r\n  p: null | Map<string | number | null | void | symbol | boolean, CacheNode<T>>\r\n}\r\n\r\ntype CacheNode<T> = TerminatedCacheNode<T> | UnterminatedCacheNode<T>\r\n\r\nfunction createCacheNode<T>(): CacheNode<T> {\r\n  return {\r\n    s: UNTERMINATED,\r\n    v: undefined,\r\n    o: null,\r\n    p: null\r\n  }\r\n}\r\n\r\n/**\r\n * Configuration options for a memoization function utilizing `WeakMap` for\r\n * its caching mechanism.\r\n *\r\n * @template Result - The type of the return value of the memoized function.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport interface WeakMapMemoizeOptions<Result = any> {\r\n  /**\r\n   * If provided, used to compare a newly generated output value against previous values in the cache.\r\n   * If a match is found, the old value is returned. This addresses the common\r\n   * ```ts\r\n   * todos.map(todo => todo.id)\r\n   * ```\r\n   * use case, where an update to another field in the original data causes a recalculation\r\n   * due to changed references, but the output is still effectively the same.\r\n   *\r\n   * @since 5.0.0\r\n   */\r\n  resultEqualityCheck?: EqualityFn<Result>\r\n}\r\n\r\n/**\r\n * Creates a tree of `WeakMap`-based cache nodes based on the identity of the\r\n * arguments it's been called with (in this case, the extracted values from your input selectors).\r\n * This allows `weakMapMemoize` to have an effectively infinite cache size.\r\n * Cache results will be kept in memory as long as references to the arguments still exist,\r\n * and then cleared out as the arguments are garbage-collected.\r\n *\r\n * __Design Tradeoffs for `weakMapMemoize`:__\r\n * - Pros:\r\n *   - It has an effectively infinite cache size, but you have no control over\r\n *   how long values are kept in cache as it's based on garbage collection and `WeakMap`s.\r\n * - Cons:\r\n *   - There's currently no way to alter the argument comparisons.\r\n *   They're based on strict reference equality.\r\n *   - It's roughly the same speed as `lruMemoize`, although likely a fraction slower.\r\n *\r\n * __Use Cases for `weakMapMemoize`:__\r\n * - This memoizer is likely best used for cases where you need to call the\r\n * same selector instance with many different arguments, such as a single\r\n * selector instance that is used in a list item component and called with\r\n * item IDs like:\r\n *   ```ts\r\n *   useSelector(state => selectSomeData(state, props.category))\r\n *   ```\r\n * @param func - The function to be memoized.\r\n * @returns A memoized function with a `.clearCache()` method attached.\r\n *\r\n * @example\r\n * <caption>Using `createSelector`</caption>\r\n * ```ts\r\n * import { createSelector, weakMapMemoize } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   items: { id: number; category: string; name: string }[]\r\n * }\r\n *\r\n * const selectItemsByCategory = createSelector(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category),\r\n *   {\r\n *     memoize: weakMapMemoize,\r\n *     argsMemoize: weakMapMemoize\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @example\r\n * <caption>Using `createSelectorCreator`</caption>\r\n * ```ts\r\n * import { createSelectorCreator, weakMapMemoize } from 'reselect'\r\n *\r\n * const createSelectorWeakMap = createSelectorCreator({ memoize: weakMapMemoize, argsMemoize: weakMapMemoize })\r\n *\r\n * const selectItemsByCategory = createSelectorWeakMap(\r\n *   [\r\n *     (state: RootState) => state.items,\r\n *     (state: RootState, category: string) => category\r\n *   ],\r\n *   (items, category) => items.filter(item => item.category === category)\r\n * )\r\n * ```\r\n *\r\n * @template Func - The type of the function that is memoized.\r\n *\r\n * @see {@link https://reselect.js.org/api/weakMapMemoize `weakMapMemoize`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @experimental\r\n */\r\nexport function weakMapMemoize<Func extends AnyFunction>(\r\n  func: Func,\r\n  options: WeakMapMemoizeOptions<ReturnType<Func>> = {}\r\n) {\r\n  let fnNode = createCacheNode()\r\n  const { resultEqualityCheck } = options\r\n\r\n  let lastResult: WeakRef<object> | undefined\r\n\r\n  let resultsCount = 0\r\n\r\n  function memoized() {\r\n    let cacheNode = fnNode\r\n    const { length } = arguments\r\n    for (let i = 0, l = length; i < l; i++) {\r\n      const arg = arguments[i]\r\n      if (\r\n        typeof arg === 'function' ||\r\n        (typeof arg === 'object' && arg !== null)\r\n      ) {\r\n        // Objects go into a WeakMap\r\n        let objectCache = cacheNode.o\r\n        if (objectCache === null) {\r\n          cacheNode.o = objectCache = new WeakMap()\r\n        }\r\n        const objectNode = objectCache.get(arg)\r\n        if (objectNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          objectCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = objectNode\r\n        }\r\n      } else {\r\n        // Primitives go into a regular Map\r\n        let primitiveCache = cacheNode.p\r\n        if (primitiveCache === null) {\r\n          cacheNode.p = primitiveCache = new Map()\r\n        }\r\n        const primitiveNode = primitiveCache.get(arg)\r\n        if (primitiveNode === undefined) {\r\n          cacheNode = createCacheNode()\r\n          primitiveCache.set(arg, cacheNode)\r\n        } else {\r\n          cacheNode = primitiveNode\r\n        }\r\n      }\r\n    }\r\n\r\n    const terminatedNode = cacheNode as unknown as TerminatedCacheNode<any>\r\n\r\n    let result\r\n\r\n    if (cacheNode.s === TERMINATED) {\r\n      result = cacheNode.v\r\n    } else {\r\n      // Allow errors to propagate\r\n      result = func.apply(null, arguments as unknown as any[])\r\n      resultsCount++\r\n    }\r\n\r\n    terminatedNode.s = TERMINATED\r\n\r\n    if (resultEqualityCheck) {\r\n      const lastResultValue = lastResult?.deref() ?? lastResult\r\n      if (\r\n        lastResultValue != null &&\r\n        resultEqualityCheck(lastResultValue as ReturnType<Func>, result)\r\n      ) {\r\n        result = lastResultValue\r\n        resultsCount !== 0 && resultsCount--\r\n      }\r\n\r\n      const needsWeakRef =\r\n        (typeof result === 'object' && result !== null) ||\r\n        typeof result === 'function'\r\n      lastResult = needsWeakRef ? new Ref(result) : result\r\n    }\r\n    terminatedNode.v = result\r\n    return result\r\n  }\r\n\r\n  memoized.clearCache = () => {\r\n    fnNode = createCacheNode()\r\n    memoized.resetResultsCount()\r\n  }\r\n\r\n  memoized.resultsCount = () => resultsCount\r\n\r\n  memoized.resetResultsCount = () => {\r\n    resultsCount = 0\r\n  }\r\n\r\n  return memoized as Func & Simplify<DefaultMemoizeFields>\r\n}\r\n","import { weakMapMemoize } from './weakMapMemoize'\r\n\r\nimport type {\r\n  Combiner,\r\n  CreateSelectorOptions,\r\n  DropFirstParameter,\r\n  ExtractMemoizerFields,\r\n  GetParamsFromSelectors,\r\n  GetStateFromSelectors,\r\n  InterruptRecursion,\r\n  OutputSelector,\r\n  Selector,\r\n  SelectorArray,\r\n  SetRequired,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\n\r\nimport {\r\n  assertIsFunction,\r\n  collectInputSelectorResults,\r\n  ensureIsArray,\r\n  getDependencies,\r\n  getDevModeChecksExecutionInfo\r\n} from './utils'\r\n\r\n/**\r\n * An instance of `createSelector`, customized with a given memoize implementation.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n *\r\n * @public\r\n */\r\nexport interface CreateSelectorFunction<\r\n  MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n> {\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments and a `combiner` function.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc-createselectoroptions createSelector}\r\n   */\r\n  <InputSelectors extends SelectorArray, Result>(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param createSelectorArgs - An arbitrary number of input selectors as separate inline arguments, a `combiner` function and an `options` object.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors as an array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc-createselectoroptions createSelector}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: InputSelectors,\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions: Simplify<\r\n        CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n      >\r\n    ]\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n\r\n  /**\r\n   * Creates a memoized selector function.\r\n   *\r\n   * @param inputSelectors - An array of input selectors.\r\n   * @param combiner - A function that Combines the input selectors and returns an output selector. Otherwise known as the result function.\r\n   * @param createSelectorOptions - An optional options object that allows for further customization per selector.\r\n   * @returns A memoized output selector.\r\n   *\r\n   * @template InputSelectors - The type of the input selectors array.\r\n   * @template Result - The return type of the `combiner` as well as the output selector.\r\n   * @template OverrideMemoizeFunction - The type of the optional `memoize` function that could be passed into the options object to override the original `memoize` function that was initially passed into `createSelectorCreator`.\r\n   * @template OverrideArgsMemoizeFunction - The type of the optional `argsMemoize` function that could be passed into the options object to override the original `argsMemoize` function that was initially passed into `createSelectorCreator`.\r\n   *\r\n   * @see {@link https://github.com/reduxjs/reselect#createselectorinputselectors--inputselectors-resultfunc-createselectoroptions createSelector}\r\n   */\r\n  <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    inputSelectors: [...InputSelectors],\r\n    combiner: Combiner<InputSelectors, Result>,\r\n    createSelectorOptions?: Simplify<\r\n      CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    >\r\n  ): OutputSelector<\r\n    InputSelectors,\r\n    Result,\r\n    OverrideMemoizeFunction,\r\n    OverrideArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n}\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param options - An options object containing the `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). It also provides additional options for customizing memoization. While the `memoize` property is mandatory, the rest are optional.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator({\r\n *   memoize: customMemoize, // Function to be used to memoize `resultFunc`\r\n *   memoizeOptions: [memoizeOption1, memoizeOption2], // Options passed to `customMemoize` as the second argument onwards\r\n *   argsMemoize: customArgsMemoize, // Function to be used to memoize the selector's arguments\r\n *   argsMemoizeOptions: [argsMemoizeOption1, argsMemoizeOption2] // Options passed to `customArgsMemoize` as the second argument onwards\r\n * })\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n *\r\n * customSelector(\r\n *   ...selectorArgs // Will be memoized by `customArgsMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-options-since-500 `createSelectorCreator`}\r\n *\r\n * @since 5.0.0\r\n * @public\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n>(\r\n  options: Simplify<\r\n    SetRequired<\r\n      CreateSelectorOptions<\r\n        typeof weakMapMemoize,\r\n        typeof weakMapMemoize,\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction\r\n      >,\r\n      'memoize'\r\n    >\r\n  >\r\n): CreateSelectorFunction<MemoizeFunction, ArgsMemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function\r\n * and options for customizing memoization behavior.\r\n *\r\n * @param memoize - The `memoize` function responsible for memoizing the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @example\r\n * ```ts\r\n * const customCreateSelector = createSelectorCreator(customMemoize, // Function to be used to memoize `resultFunc`\r\n *   option1, // Will be passed as second argument to `customMemoize`\r\n *   option2, // Will be passed as third argument to `customMemoize`\r\n *   option3 // Will be passed as fourth argument to `customMemoize`\r\n * )\r\n *\r\n * const customSelector = customCreateSelector(\r\n *   [inputSelector1, inputSelector2],\r\n *   resultFunc // `resultFunc` will be passed as the first argument to `customMemoize`\r\n * )\r\n * ```\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelectorCreator#using-memoize-and-memoizeoptions `createSelectorCreator`}\r\n *\r\n * @public\r\n */\r\nexport function createSelectorCreator<MemoizeFunction extends UnknownMemoizer>(\r\n  memoize: MemoizeFunction,\r\n  ...memoizeOptionsFromArgs: DropFirstParameter<MemoizeFunction>\r\n): CreateSelectorFunction<MemoizeFunction>\r\n\r\n/**\r\n * Creates a selector creator function with the specified memoization function and options for customizing memoization behavior.\r\n *\r\n * @param memoizeOrOptions - Either A `memoize` function or an `options` object containing the `memoize` function.\r\n * @param memoizeOptionsFromArgs - Optional configuration options for the memoization function. These options are then passed to the memoize function as the second argument onwards.\r\n * @returns A customized `createSelector` function.\r\n *\r\n * @template MemoizeFunction - The type of the memoize function that is used to memoize the `resultFunc` inside `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`).\r\n * @template ArgsMemoizeFunction - The type of the optional memoize function that is used to memoize the arguments passed into the output selector generated by `createSelector` (e.g., `lruMemoize` or `weakMapMemoize`). If none is explicitly provided, `weakMapMemoize` will be used.\r\n * @template MemoizeOrOptions - The type of the first argument. It can either be a `memoize` function or an `options` object containing the `memoize` function.\r\n */\r\nexport function createSelectorCreator<\r\n  MemoizeFunction extends UnknownMemoizer,\r\n  ArgsMemoizeFunction extends UnknownMemoizer,\r\n  MemoizeOrOptions extends\r\n    | MemoizeFunction\r\n    | SetRequired<\r\n        CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n        'memoize'\r\n      >\r\n>(\r\n  memoizeOrOptions: MemoizeOrOptions,\r\n  ...memoizeOptionsFromArgs: MemoizeOrOptions extends SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  >\r\n    ? never\r\n    : DropFirstParameter<MemoizeFunction>\r\n) {\r\n  /** options initially passed into `createSelectorCreator`. */\r\n  const createSelectorCreatorOptions: SetRequired<\r\n    CreateSelectorOptions<MemoizeFunction, ArgsMemoizeFunction>,\r\n    'memoize'\r\n  > = typeof memoizeOrOptions === 'function'\r\n    ? {\r\n        memoize: memoizeOrOptions as MemoizeFunction,\r\n        memoizeOptions: memoizeOptionsFromArgs\r\n      }\r\n    : memoizeOrOptions\r\n\r\n  const createSelector = <\r\n    InputSelectors extends SelectorArray,\r\n    Result,\r\n    OverrideMemoizeFunction extends UnknownMemoizer = MemoizeFunction,\r\n    OverrideArgsMemoizeFunction extends UnknownMemoizer = ArgsMemoizeFunction\r\n  >(\r\n    ...createSelectorArgs: [\r\n      ...inputSelectors: [...InputSelectors],\r\n      combiner: Combiner<InputSelectors, Result>,\r\n      createSelectorOptions?: CreateSelectorOptions<\r\n        MemoizeFunction,\r\n        ArgsMemoizeFunction,\r\n        OverrideMemoizeFunction,\r\n        OverrideArgsMemoizeFunction\r\n      >\r\n    ]\r\n  ) => {\r\n    let recomputations = 0\r\n    let dependencyRecomputations = 0\r\n    let lastResult: Result\r\n\r\n    // Due to the intricacies of rest params, we can't do an optional arg after `...createSelectorArgs`.\r\n    // So, start by declaring the default value here.\r\n    // (And yes, the words 'memoize' and 'options' appear too many times in this next sequence.)\r\n    let directlyPassedOptions: CreateSelectorOptions<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    > = {}\r\n\r\n    // Normally, the result func or \"combiner\" is the last arg\r\n    let resultFunc = createSelectorArgs.pop() as\r\n      | Combiner<InputSelectors, Result>\r\n      | CreateSelectorOptions<\r\n          MemoizeFunction,\r\n          ArgsMemoizeFunction,\r\n          OverrideMemoizeFunction,\r\n          OverrideArgsMemoizeFunction\r\n        >\r\n\r\n    // If the result func is actually an _object_, assume it's our options object\r\n    if (typeof resultFunc === 'object') {\r\n      directlyPassedOptions = resultFunc\r\n      // and pop the real result func off\r\n      resultFunc = createSelectorArgs.pop() as Combiner<InputSelectors, Result>\r\n    }\r\n\r\n    assertIsFunction(\r\n      resultFunc,\r\n      `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`\r\n    )\r\n\r\n    // Determine which set of options we're using. Prefer options passed directly,\r\n    // but fall back to options given to `createSelectorCreator`.\r\n    const combinedOptions = {\r\n      ...createSelectorCreatorOptions,\r\n      ...directlyPassedOptions\r\n    }\r\n\r\n    const {\r\n      memoize,\r\n      memoizeOptions = [],\r\n      argsMemoize = weakMapMemoize,\r\n      argsMemoizeOptions = [],\r\n      devModeChecks = {}\r\n    } = combinedOptions\r\n\r\n    // Simplifying assumption: it's unlikely that the first options arg of the provided memoizer\r\n    // is an array. In most libs I've looked at, it's an equality function or options object.\r\n    // Based on that, if `memoizeOptions` _is_ an array, we assume it's a full\r\n    // user-provided array of options. Otherwise, it must be just the _first_ arg, and so\r\n    // we wrap it in an array so we can apply it.\r\n    const finalMemoizeOptions = ensureIsArray(memoizeOptions)\r\n    const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions)\r\n    const dependencies = getDependencies(createSelectorArgs) as InputSelectors\r\n\r\n    const memoizedResultFunc = memoize(function recomputationWrapper() {\r\n      recomputations++\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      return (resultFunc as Combiner<InputSelectors, Result>).apply(\r\n        null,\r\n        arguments\r\n      )\r\n    }, ...finalMemoizeOptions) as Combiner<InputSelectors, Result> &\r\n      ExtractMemoizerFields<OverrideMemoizeFunction>\r\n\r\n    let firstRun = true\r\n\r\n    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.\r\n    const selector = argsMemoize(function dependenciesChecker() {\r\n      dependencyRecomputations++\r\n      /** Return values of input selectors which the `resultFunc` takes as arguments. */\r\n      const inputSelectorResults = collectInputSelectorResults(\r\n        dependencies,\r\n        arguments\r\n      )\r\n\r\n      if (process.env.NODE_ENV !== 'production') {\r\n        const { identityFunctionCheck, inputStabilityCheck } =\r\n          getDevModeChecksExecutionInfo(firstRun, devModeChecks)\r\n        if (identityFunctionCheck.shouldRun) {\r\n          identityFunctionCheck.run(\r\n            resultFunc as Combiner<InputSelectors, Result>\r\n          )\r\n        }\r\n\r\n        if (inputStabilityCheck.shouldRun) {\r\n          // make a second copy of the params, to check if we got the same results\r\n          const inputSelectorResultsCopy = collectInputSelectorResults(\r\n            dependencies,\r\n            arguments\r\n          )\r\n\r\n          inputStabilityCheck.run(\r\n            { inputSelectorResults, inputSelectorResultsCopy },\r\n            { memoize, memoizeOptions: finalMemoizeOptions },\r\n            arguments\r\n          )\r\n        }\r\n\r\n        if (firstRun) firstRun = false\r\n      }\r\n\r\n      // apply arguments instead of spreading for performance.\r\n      // @ts-ignore\r\n      lastResult = memoizedResultFunc.apply(null, inputSelectorResults)\r\n\r\n      return lastResult\r\n    }, ...finalArgsMemoizeOptions) as unknown as Selector<\r\n      GetStateFromSelectors<InputSelectors>,\r\n      Result,\r\n      GetParamsFromSelectors<InputSelectors>\r\n    > &\r\n      ExtractMemoizerFields<OverrideArgsMemoizeFunction>\r\n\r\n    return Object.assign(selector, {\r\n      resultFunc,\r\n      memoizedResultFunc,\r\n      dependencies,\r\n      dependencyRecomputations: () => dependencyRecomputations,\r\n      resetDependencyRecomputations: () => {\r\n        dependencyRecomputations = 0\r\n      },\r\n      lastResult: () => lastResult,\r\n      recomputations: () => recomputations,\r\n      resetRecomputations: () => {\r\n        recomputations = 0\r\n      },\r\n      memoize,\r\n      argsMemoize\r\n    }) as OutputSelector<\r\n      InputSelectors,\r\n      Result,\r\n      OverrideMemoizeFunction,\r\n      OverrideArgsMemoizeFunction\r\n    >\r\n  }\r\n  return createSelector as CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  >\r\n}\r\n\r\n/**\r\n * Accepts one or more \"input selectors\" (either as separate arguments or a single array),\r\n * a single \"result function\" / \"combiner\", and an optional options object, and\r\n * generates a memoized selector function.\r\n *\r\n * @see {@link https://reselect.js.org/api/createSelector `createSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createSelector =\r\n  /* #__PURE__ */ createSelectorCreator(weakMapMemoize)\r\n","import { createSelector } from './createSelectorCreator'\r\n\r\nimport type { CreateSelectorFunction } from './createSelectorCreator'\r\nimport type {\r\n  InterruptRecursion,\r\n  ObjectValuesToTuple,\r\n  OutputSelector,\r\n  Selector,\r\n  Simplify,\r\n  UnknownMemoizer\r\n} from './types'\r\nimport { assertIsObject } from './utils'\r\nimport type { weakMapMemoize } from './weakMapMemoize'\r\n\r\n/**\r\n *\r\n * @WIP\r\n */\r\ntype SelectorsMap<T extends SelectorsObject> = {\r\n  [Key in keyof T]: ReturnType<T[Key]>\r\n}\r\n\r\n// TODO: Write more type tests for `TypedStructuredSelectorCreator`.\r\n/**\r\n * Allows you to create a pre-typed version of {@linkcode createStructuredSelector createStructuredSelector}\r\n * For your root state.\r\n *\r\n * @since 5.0.0\r\n * @public\r\n * @WIP\r\n */\r\nexport interface TypedStructuredSelectorCreator<RootState = any> {\r\n  <\r\n    InputSelectorsObject extends {\r\n      [Key in keyof RootState]: Selector<RootState, RootState[Key], []>\r\n    } = {\r\n      [Key in keyof RootState]: Selector<RootState, RootState[Key], []>\r\n    },\r\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n  >(\r\n    selectors: InputSelectorsObject,\r\n    selectorCreator?: CreateSelectorFunction<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction\r\n    >\r\n  ): OutputSelector<\r\n    ObjectValuesToTuple<InputSelectorsObject>,\r\n    SelectorsMap<InputSelectorsObject>,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  >\r\n}\r\n\r\ninterface SelectorsObject {\r\n  [key: string]: Selector\r\n}\r\n\r\n/**\r\n * It provides a way to create structured selectors.\r\n * The structured selector can take multiple input selectors\r\n * and map their output to an object with specific keys.\r\n *\r\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n *\r\n * @public\r\n */\r\nexport interface StructuredSelectorCreator {\r\n  /**\r\n   * A convenience function that simplifies returning an object\r\n   * made up of selector results.\r\n   *\r\n   * @param inputSelectorsObject - A key value pair consisting of input selectors.\r\n   * @param selectorCreator - A custom selector creator function. It defaults to `createSelector`.\r\n   * @returns A memoized structured selector.\r\n   *\r\n   * @example\r\n   * <caption>Modern Use Case</caption>\r\n   * ```ts\r\n   * import { createSelector, createStructuredSelector } from 'reselect'\r\n   *\r\n   * interface RootState {\r\n   *   todos: {\r\n   *     id: number\r\n   *     completed: boolean\r\n   *     title: string\r\n   *     description: string\r\n   *   }[]\r\n   *   alerts: { id: number; read: boolean }[]\r\n   * }\r\n   *\r\n   * // This:\r\n   * const structuredSelector = createStructuredSelector(\r\n   *   {\r\n   *     todos: (state: RootState) => state.todos,\r\n   *     alerts: (state: RootState) => state.alerts,\r\n   *     todoById: (state: RootState, id: number) => state.todos[id]\r\n   *   },\r\n   *   createSelector\r\n   * )\r\n   *\r\n   * // Is essentially the same as this:\r\n   * const selector = createSelector(\r\n   *   [\r\n   *     (state: RootState) => state.todos,\r\n   *     (state: RootState) => state.alerts,\r\n   *     (state: RootState, id: number) => state.todos[id]\r\n   *   ],\r\n   *   (todos, alerts, todoById) => {\r\n   *     return {\r\n   *       todos,\r\n   *       alerts,\r\n   *       todoById\r\n   *     }\r\n   *   }\r\n   * )\r\n   * ```\r\n   *\r\n   * @example\r\n   * <caption>Simple Use Case</caption>\r\n   * ```ts\r\n   * const selectA = state => state.a\r\n   * const selectB = state => state.b\r\n   *\r\n   * // The result function in the following selector\r\n   * // is simply building an object from the input selectors\r\n   * const structuredSelector = createSelector(selectA, selectB, (a, b) => ({\r\n   *   a,\r\n   *   b\r\n   * }))\r\n   *\r\n   * const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }\r\n   * ```\r\n   *\r\n   * @template InputSelectorsObject - The shape of the input selectors object.\r\n   * @template MemoizeFunction - The type of the memoize function that is used to create the structured selector. It defaults to `weakMapMemoize`.\r\n   * @template ArgsMemoizeFunction - The type of the of the memoize function that is used to memoize the arguments passed into the generated structured selector. It defaults to `weakMapMemoize`.\r\n   *\r\n   * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n   */\r\n  <\r\n    InputSelectorsObject extends SelectorsObject,\r\n    MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n    ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n  >(\r\n    inputSelectorsObject: InputSelectorsObject,\r\n    selectorCreator?: CreateSelectorFunction<\r\n      MemoizeFunction,\r\n      ArgsMemoizeFunction\r\n    >\r\n  ): OutputSelector<\r\n    ObjectValuesToTuple<InputSelectorsObject>,\r\n    Simplify<SelectorsMap<InputSelectorsObject>>,\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > &\r\n    InterruptRecursion\r\n}\r\n\r\n/**\r\n * A convenience function that simplifies returning an object\r\n * made up of selector results.\r\n *\r\n * @example\r\n * <caption>Modern Use Case</caption>\r\n * ```ts\r\n * import { createSelector, createStructuredSelector } from 'reselect'\r\n *\r\n * interface RootState {\r\n *   todos: {\r\n *     id: number\r\n *     completed: boolean\r\n *     title: string\r\n *     description: string\r\n *   }[]\r\n *   alerts: { id: number; read: boolean }[]\r\n * }\r\n *\r\n * // This:\r\n * const structuredSelector = createStructuredSelector(\r\n *   {\r\n *     todos: (state: RootState) => state.todos,\r\n *     alerts: (state: RootState) => state.alerts,\r\n *     todoById: (state: RootState, id: number) => state.todos[id]\r\n *   },\r\n *   createSelector\r\n * )\r\n *\r\n * // Is essentially the same as this:\r\n * const selector = createSelector(\r\n *   [\r\n *     (state: RootState) => state.todos,\r\n *     (state: RootState) => state.alerts,\r\n *     (state: RootState, id: number) => state.todos[id]\r\n *   ],\r\n *   (todos, alerts, todoById) => {\r\n *     return {\r\n *       todos,\r\n *       alerts,\r\n *       todoById\r\n *     }\r\n *   }\r\n * )\r\n * ```\r\n *\r\n * @see {@link https://reselect.js.org/api/createStructuredSelector `createStructuredSelector`}\r\n *\r\n * @public\r\n */\r\nexport const createStructuredSelector: StructuredSelectorCreator = (<\r\n  InputSelectorsObject extends SelectorsObject,\r\n  MemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize,\r\n  ArgsMemoizeFunction extends UnknownMemoizer = typeof weakMapMemoize\r\n>(\r\n  inputSelectorsObject: InputSelectorsObject,\r\n  selectorCreator: CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  > = createSelector as CreateSelectorFunction<\r\n    MemoizeFunction,\r\n    ArgsMemoizeFunction\r\n  >\r\n) => {\r\n  assertIsObject(\r\n    inputSelectorsObject,\r\n    'createStructuredSelector expects first argument to be an object ' +\r\n      `where each property is a selector, instead received a ${typeof inputSelectorsObject}`\r\n  )\r\n  const inputSelectorKeys = Object.keys(inputSelectorsObject)\r\n  const dependencies = inputSelectorKeys.map(key => inputSelectorsObject[key])\r\n  const structuredSelector = selectorCreator(\r\n    dependencies,\r\n    (...inputSelectorResults: any[]) => {\r\n      return inputSelectorResults.reduce((composition, value, index) => {\r\n        composition[inputSelectorKeys[index]] = value\r\n        return composition\r\n      }, {})\r\n    }\r\n  )\r\n  return structuredSelector\r\n}) as StructuredSelectorCreator\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}